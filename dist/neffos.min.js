"use strict";var __awaiter=this&&this.__awaiter||function(a,b,c,d){return new(c||(c=Promise))(function(e,f){function g(a){try{i(d.next(a))}catch(a){f(a)}}function h(a){try{i(d["throw"](a))}catch(a){f(a)}}function i(a){a.done?e(a.value):new c(function(b){b(a.value)}).then(g,h)}i((d=d.apply(a,b||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const isBrowser="undefined"!=typeof window;var WebSocket;WebSocket=isBrowser?window.WebSocket:require("ws"),exports.OnNamespaceConnect="_OnNamespaceConnect",exports.OnNamespaceConnected="_OnNamespaceConnected",exports.OnNamespaceDisconnect="_OnNamespaceDisconnect",exports.OnRoomJoin="_OnRoomJoin",exports.OnRoomJoined="_OnRoomJoined",exports.OnRoomLeave="_OnRoomLeave",exports.OnRoomLeft="_OnRoomLeft",exports.OnAnyEvent="_OnAnyEvent",exports.OnNativeMessage="_OnNativeMessage";const ackBinary="M",ackIDBinary="A",ackNotOKBinary="H",waitIsConfirmationPrefix="#",waitComesFromClientPrefix="$";function isSystemEvent(a){return!(a!==exports.OnNamespaceConnect&&a!==exports.OnNamespaceConnected&&a!==exports.OnNamespaceDisconnect&&a!==exports.OnRoomJoin&&a!==exports.OnRoomJoined&&a!==exports.OnRoomLeave&&a!==exports.OnRoomLeft)}exports.isSystemEvent=isSystemEvent;function isEmpty(a){return!(void 0!==a)||!(null!==a)||("string"==typeof a||a instanceof String?0===a.length||""===a:!!(a instanceof Error)&&isEmpty(a.message))}class Message{isConnect(){return this.Event==exports.OnNamespaceConnect||!1}isDisconnect(){return this.Event==exports.OnNamespaceDisconnect||!1}isRoomJoin(){return this.Event==exports.OnRoomJoin||!1}isRoomLeft(){return this.Event==exports.OnRoomLeft||!1}isWait(){return!isEmpty(this.wait)&&(!(this.wait[0]!=waitIsConfirmationPrefix)||this.wait[0]==waitComesFromClientPrefix||!1)}}exports.Message=Message;const messageSeparator=";",validMessageSepCount=7,trueString="1",falseString="0";function serializeMessage(a){if(a.IsNative&&isEmpty(a.wait))return a.Body;let b=falseString,c=falseString,d=a.Body||"";return a.isError&&(d=a.Err,b=trueString),a.isNoOp&&(c=trueString),[a.wait||"",a.Namespace,a.Room||"",a.Event||"",b,c,d].join(messageSeparator)}function deserializeMessage(a,b){var c=new Message;if(0==a.length)return c.isInvalid=!0,c;let d=a.split(messageSeparator,validMessageSepCount);if(d.length!=validMessageSepCount)return b?(c.Event=exports.OnNativeMessage,c.Body=a):c.isInvalid=!0,c;c.wait=d[0],c.Namespace=d[1],c.Room=d[2],c.Event=d[3],c.isError=d[4]==trueString||!1,c.isNoOp=d[5]==trueString||!1;let e=d[6];return isEmpty(e)?c.Body="":c.isError?c.Err=e:c.Body=e,c.isInvalid=!1,c.IsForced=!1,c.IsLocal=!1,c.IsNative=b&&c.Event==exports.OnNativeMessage||!1,c}function genWait(){if(!isBrowser){let a=process.hrtime();return waitComesFromClientPrefix+1e9*a[0]+a[1]}else{let a=window.performance.now();return waitComesFromClientPrefix+a.toString()}}function genWaitConfirmation(a){return waitIsConfirmationPrefix+a}function genEmptyReplyToWait(a){return a+messageSeparator.repeat(validMessageSepCount-1)}class Room{constructor(a,b){this.nsConn=a,this.name=b}emit(a,b){let c=new Message;return c.Namespace=this.nsConn.namespace,c.Room=this.name,c.Event=a,c.Body=b,this.nsConn.conn.write(c)}leave(){let a=new Message;return a.Namespace=this.nsConn.namespace,a.Room=this.name,a.Event=exports.OnRoomLeave,this.nsConn.askRoomLeave(a)}}exports.Room=Room;class NSConn{constructor(a,b,c){this.conn=a,this.namespace=b,this.events=c,this.rooms=new Map}emit(a,b){let c=new Message;return c.Namespace=this.namespace,c.Event=a,c.Body=b,this.conn.write(c)}ask(a,b){let c=new Message;return c.Namespace=this.namespace,c.Event=a,c.Body=b,this.conn.ask(c)}joinRoom(a){return __awaiter(this,void 0,void 0,function*(){return yield this.askRoomJoin(a)})}room(a){return this.rooms.get(a)}leaveAll(){return __awaiter(this,void 0,void 0,function*(){let a=new Message;return a.Namespace=this.namespace,a.Event=exports.OnRoomLeft,a.IsLocal=!0,this.rooms.forEach((b,c)=>__awaiter(this,void 0,void 0,function*(){a.Room=c;try{yield this.askRoomLeave(a)}catch(a){return a}})),null})}forceLeaveAll(a){let b=new Message;b.Namespace=this.namespace,b.Event=exports.OnRoomLeave,b.IsForced=!0,b.IsLocal=a,this.rooms.forEach((a,c)=>{b.Room=c,fireEvent(this,b),this.rooms.delete(c),b.Event=exports.OnRoomLeft,fireEvent(this,b),b.Event=exports.OnRoomLeave})}disconnect(){let a=new Message;return a.Namespace=this.namespace,a.Event=exports.OnNamespaceDisconnect,this.conn.askDisconnect(a)}askRoomJoin(a){return new Promise((b,c)=>__awaiter(this,void 0,void 0,function*(){let d=this.rooms.get(a);if(void 0!==d)return void b(d);let e=new Message;e.Namespace=this.namespace,e.Room=a,e.Event=exports.OnRoomJoin,e.IsLocal=!0;try{yield this.conn.ask(e)}catch(a){return void c(a)}let f=fireEvent(this,e);return isEmpty(f)?void(d=new Room(this,a),this.rooms.set(a,d),e.Event=exports.OnRoomJoined,fireEvent(this,e),b(d)):void c(f)}))}askRoomLeave(a){return __awaiter(this,void 0,void 0,function*(){if(!this.rooms.has(a.Room))return exports.ErrBadRoom;try{yield this.conn.ask(a)}catch(a){return a}let b=fireEvent(this,a);return isEmpty(b)?(this.rooms.delete(a.Room),a.Event=exports.OnRoomLeft,fireEvent(this,a),null):b})}replyRoomJoin(a){if(!(isEmpty(a.wait)||a.isNoOp)){if(!this.rooms.has(a.Room)){let b=fireEvent(this,a);if(!isEmpty(b))return a.Err=b.message,void this.conn.write(a);this.rooms.set(a.Room,new Room(this,a.Room)),a.Event=exports.OnRoomJoined,fireEvent(this,a)}this.conn.writeEmptyReply(a.wait)}}replyRoomLeave(a){return isEmpty(a.wait)||a.isNoOp?void 0:this.rooms.has(a.Room)?void(fireEvent(this,a),this.rooms.delete(a.Room),this.conn.writeEmptyReply(a.wait),a.Event=exports.OnRoomLeft,fireEvent(this,a)):void this.conn.writeEmptyReply(a.wait)}}exports.NSConn=NSConn;function fireEvent(a,b){return a.events.hasOwnProperty(b.Event)?a.events[b.Event](a,b):a.events.hasOwnProperty(exports.OnAnyEvent)?a.events[exports.OnAnyEvent](a,b):null}function getEvents(a,b){return a.hasOwnProperty(b)?a[b]:null}function dial(a,b,c){return-1==a.indexOf("ws")&&(a="ws://"+a),new Promise((d,e)=>{WebSocket||e("WebSocket is not accessible through this browser."),void 0===b&&e("connHandler is empty.");let f=new WebSocket(a,c),g=new Conn(f,b,c);f.binaryType="arraybuffer",f.onmessage=a=>{let b=g.handle(a);return isEmpty(b)?void(g.isAcknowledged()&&d(g)):void e(b)},f.onopen=()=>{f.send(ackBinary)},f.onerror=a=>{g.close(),e(a)}})}exports.dial=dial,exports.ErrInvalidPayload=new Error("invalid payload"),exports.ErrBadNamespace=new Error("bad namespace"),exports.ErrBadRoom=new Error("bad room"),exports.ErrClosed=new Error("use of closed connection"),exports.ErrWrite=new Error("write closed");class Conn{constructor(a,b,c){this.conn=a,this._isAcknowledged=!1;let d=b.hasOwnProperty("");this.allowNativeMessages=d&&b[""].hasOwnProperty(exports.OnNativeMessage),this.queue=[],this.waitingMessages=new Map,this.namespaces=b,this.connectedNamespaces=new Map,this.closed=!1,this.conn.onclose=()=>(this.close(),null)}isAcknowledged(){return this._isAcknowledged}handle(a){if(!this._isAcknowledged){let b=this.handleAck(a.data);return null==b?(this._isAcknowledged=!0,this.handleQueue()):this.conn.close(),b}return this.handleMessage(a.data)}handleAck(a){let b=a[0];switch(b){case ackIDBinary:let c=a.slice(1);this.ID=c;break;case ackNotOKBinary:let d=a.slice(1);return new Error(d);default:return this.queue.push(a),null;}}handleQueue(){null==this.queue||0==this.queue.length||this.queue.forEach((a,b)=>{this.queue.splice(b,1),this.handleMessage(a)})}handleMessage(a){let b=deserializeMessage(a,this.allowNativeMessages);if(b.isInvalid)return exports.ErrInvalidPayload;if(b.IsNative&&this.allowNativeMessages){let a=this.namespace("");return fireEvent(a,b)}if(b.isWait()){let a=this.waitingMessages.get(b.wait);if(null!=a)return void a(b)}const c=this.namespace(b.Namespace);switch(b.Event){case exports.OnNamespaceConnect:this.replyConnect(b);break;case exports.OnNamespaceDisconnect:this.replyDisconnect(b);break;case exports.OnRoomJoin:if(c!==void 0){c.replyRoomJoin(b);break}case exports.OnRoomLeave:if(c!==void 0){c.replyRoomLeave(b);break}default:if(c===void 0)return exports.ErrBadNamespace;b.IsLocal=!1;let a=fireEvent(c,b);if(!isEmpty(a))return b.Err=a.message,this.write(b),a;}return null}connect(a){return this.askConnect(a)}namespace(a){return this.connectedNamespaces.get(a)}replyConnect(a){if(isEmpty(a.wait)||a.isNoOp)return;let b=this.namespace(a.Namespace);if(void 0!==b)return void this.writeEmptyReply(a.wait);let c=getEvents(this.namespaces,a.Namespace);return void 0===c?(a.Err=exports.ErrBadNamespace.message,void this.write(a)):void(b=new NSConn(this,a.Namespace,c),this.connectedNamespaces.set(a.Namespace,b),this.writeEmptyReply(a.wait),a.Event=exports.OnNamespaceConnected,fireEvent(b,a))}replyDisconnect(a){if(!(isEmpty(a.wait)||a.isNoOp)){let b=this.namespace(a.Namespace);return void 0===b?void this.writeEmptyReply(a.wait):void(b.forceLeaveAll(!0),this.connectedNamespaces.delete(a.Namespace),this.writeEmptyReply(a.wait),fireEvent(b,a))}}ask(a){return new Promise((b,c)=>this.isClosed()?void c(exports.ErrClosed):(a.wait=genWait(),this.waitingMessages.set(a.wait,a=>a.isError?void c(new Error(a.Err)):void b(a)),!this.write(a))?void c(exports.ErrWrite):void 0)}askConnect(a){return new Promise((b,c)=>__awaiter(this,void 0,void 0,function*(){let d=this.namespace(a);if(void 0!==d)return void b(d);let e=getEvents(this.namespaces,a);if(void 0===e)return void c(exports.ErrBadNamespace);let f=new Message;f.Namespace=a,f.Event=exports.OnNamespaceConnect,f.IsLocal=!0,d=new NSConn(this,a,e);let g=fireEvent(d,f);if(!isEmpty(g))return void c(g);try{yield this.ask(f)}catch(a){return void c(a)}this.connectedNamespaces.set(a,d),f.Event=exports.OnNamespaceConnected,fireEvent(d,f),b(d)}))}askDisconnect(a){return __awaiter(this,void 0,void 0,function*(){let b=this.namespace(a.Namespace);if(void 0===b)return exports.ErrBadNamespace;try{yield this.ask(a)}catch(a){return a}return b.forceLeaveAll(!0),this.connectedNamespaces.delete(a.Namespace),a.IsLocal=!0,fireEvent(b,a)})}isClosed(){return this.closed||this.conn.readyState==this.conn.CLOSED||!1}write(a){if(this.isClosed())return!1;if(!a.isConnect()&&!a.isDisconnect()){let b=this.namespace(a.Namespace);if(void 0===b)return!1;if(!isEmpty(a.Room)&&!a.isRoomJoin()&&!a.isRoomLeft()&&!b.rooms.has(a.Room))return!1}return this.conn.send(serializeMessage(a)),!0}writeEmptyReply(a){this.conn.send(genEmptyReplyToWait(a))}close(){if(this.closed)return;let a=new Message;a.Event=exports.OnNamespaceDisconnect,a.IsForced=!0,a.IsLocal=!0,this.connectedNamespaces.forEach(b=>{b.forceLeaveAll(!0),a.Namespace=b.namespace,fireEvent(b,a),this.connectedNamespaces.delete(b.namespace)}),this.waitingMessages.clear(),this.conn.readyState===this.conn.OPEN&&this.conn.close(),this.closed=!0}}exports.Conn=Conn;